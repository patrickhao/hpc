#include <iostream>

int main() {
  // 使用&可以访问当前作用域内的所有变量，且是以引用的方式，因此也就可以修改当前作用域内的变量
  // 生成的函数类中，用到的变量是以引用初始化成员变量的
  // 可以修改可访问变量的值，也就无需mutable关键字了

  int a{1};

  auto func1 = [&]() { a++; };

  func1();

  std::cout << "after func1 call, a is " << a << std::endl;

  // 直接通过引用的方式暴露所有的变量是不推荐的，因为这可能导致一些危险的操作，与此同时，全部使用=也是不高效的，这可能会导致一些拷贝操作
  // 可以通过一些方法只暴露部分变量，可以指定每个变量如何捕获，如果指定了，只能访问指定的特定变量
  // 没有加上&的默认是按值传递，按值传递不能加上=，这是不合法的，直接用名字即可

  int b{2};

  int c{3};

  // auto func2 = [b, &c]() {
  //   b = 0;
  //   c = 0;
  // };

  auto func2 = [b, &c]() mutable {
    // 如果想要在这种方式下修改=类型的变量，也要加上mutable关键字，但是由于是传值，因此也不会实际修改该值
    b = 0;
    c = 0;
  };

  // 也可以对所有变量使用一个大的，再指定个别变量的暴露类型，如果使用这种方式，大的默认的捕获方式应该放在最前面
  auto func3 = [=, &a]() { a = 1; };

  return 0;
}